/*
  baselinegrid.scss | MIT License | https://github.com/jeromev/baselinegrid.scss
  -----------------------------------------------------------------------------
  A modern SCSS toolkit for aligning text and layout to a baseline grid.
  Features responsive scaling, typographic precision, and utility mixins.
  -----------------------------------------------------------------------------
  USAGE:
    @use 'path/to/_baselinegrid.scss' as *;
    .my-class { @include set(20px); }
    .container { @include pad-scale(); }
    .element { @include respond-to('m') { font-size: 20px; } }
  -----------------------------------------------------------------------------
*/
//==================================================================================
// VERSION
//==================================================================================
$version: '2.2.0' !default;

//==================================================================================
// LIBRARIES (SASS MODULES)
//==================================================================================
@use "sass:map";
@use "sass:math";
@use "sass:meta";

//==================================================================================
// CONFIGURATION OPTIONS
//==================================================================================

// Responsive scale map: defines font-size, line-height, min-width, and padding for breakpoints.
// This is the primary configuration - adjust these values to fit your design system.
$scale: (
  'xs': (
    'font-size': 15px,    // Base font size for smallest screens
    'line-height': 24px,  // Should be an even integer for best Chrome rendering
    'min-width': 0,       // Base/mobile-first (no media query)
    'pad': 1              // grid-units for padding
  ),
  's': (
    'font-size': 17px,
    'line-height': 26px,
    'min-width': 375px,   // Small phones
    'pad': 2
  ),
  'm': (
    'font-size': 19px,
    'line-height': 28px,
    'min-width': 560px,   // Tablets
    'pad': 3
  ),
  'l': (
    'font-size': 20px,
    'line-height': 30px,
    'min-width': 768px,   // Desktop
    'pad': 4
  ),
  'xl': (
    'font-size': 21px,
    'line-height': 32px,
    'min-width': 1024px,  // Large desktop
    'pad': 5
  ),
  'xxl': (
    'font-size': 23px,
    'line-height': 34px,
    'min-width': 1440px,  // Extra large desktop
    'pad': 8
  ),
  'ul': (
    'font-size': 25px,
    'line-height': 36px,
    'min-width': 2004px,  // Ultra large desktop
    'pad': 10
  )
) !default;

// Breakpoint system derived from $scale - used for respond-to() mixin
// This automatically stays in sync with your scale configuration
$breakpoints: (
  'xs': map.get(map.get($scale, 'xs'), 'min-width'),
  's': map.get(map.get($scale, 's'), 'min-width'),
  'm': map.get(map.get($scale, 'm'), 'min-width'),
  'l': map.get(map.get($scale, 'l'), 'min-width'),
  'xl': map.get(map.get($scale, 'xl'), 'min-width'),
  'xxl': map.get(map.get($scale, 'xxl'), 'min-width'),
  'ul': map.get(map.get($scale, 'ul'), 'min-width')
) !default;

// Optical adjustment for horizontal grid units (tweak for visual balance)
$width-optical-adjustment: 1.1 !default;  // relative to 1 vertical grid-unit
$right-side-adjustment: 0.8 !default;     // relative to 1 horizontal grid-unit (typo fixed)
$debug: 0 !default;                       // Set to 1 to show grid overlay
$preset: 'Georgia' !default;              // Font metrics preset (expandable)

//==================================================================================
// CONFIGURATION VALIDATION
//==================================================================================

/// Validate scale configuration at compile time
/// Ensures all required breakpoints and properties are present
@mixin _validate-scale() {
  $required-breakpoints: ('xs', 's', 'm', 'l', 'xl', 'xxl', 'ul');
  $required-props: ('font-size', 'line-height', 'min-width', 'pad');
  
  // Check all required breakpoints exist
  @each $bp in $required-breakpoints {
    @if not map.has-key($scale, $bp) {
      @error 'baselinegrid.scss: Scale missing required breakpoint "#{$bp}". Required breakpoints: #{$required-breakpoints}';
    }
    
    $bp-config: map.get($scale, $bp);
    
    // Check all required properties exist for this breakpoint
    @each $prop in $required-props {
      @if not map.has-key($bp-config, $prop) {
        @error 'baselinegrid.scss: Breakpoint "#{$bp}" missing required property "#{$prop}". Required properties: #{$required-props}';
      }
    }
    
    // Validate line-height is even integer (for better rendering)
    $lh: map.get($bp-config, 'line-height');
    @if meta.type-of($lh) == 'number' and math.unit($lh) == 'px' {
      $lh-unitless: math.div($lh, 1px);
      @if $lh-unitless % 2 != 0 {
        @warn 'baselinegrid.scss: Breakpoint "#{$bp}" has odd line-height (#{$lh}). Even integers (e.g., 24px, 26px, 28px) are recommended for better browser rendering.';
      }
    }
    
    // Validate min-width is 0 for 'xs' breakpoint
    @if $bp == 'xs' {
      $min-width: map.get($bp-config, 'min-width');
      @if $min-width != 0 {
        @error 'baselinegrid.scss: First breakpoint "xs" must have min-width: 0, got: #{$min-width}';
      }
    }
  }
  
  // Validate optical adjustment is in reasonable range
  @if $width-optical-adjustment < 0.5 or $width-optical-adjustment > 2 {
    @warn 'baselinegrid.scss: width-optical-adjustment (#{$width-optical-adjustment}) is outside typical range (0.5-2.0). This may cause unexpected horizontal spacing.';
  }
  
  // Warn if debug mode is enabled
  @if $debug == 1 {
    @warn 'baselinegrid.scss: Debug mode is ENABLED. Grid overlay will be visible. Set $debug: 0 before deploying to production.';
  }
}

// Run validation immediately when module is configured
@include _validate-scale();

//==================================================================================
// RESPONSIVE BREAKPOINT MIXIN
//==================================================================================

/// Generate media query for a specific breakpoint
/// @param {String} $breakpoint - Breakpoint name
/// @example scss - Media query
///   .element {
///     font-size: 16px;
///     @include bg.respond-to('m') {
///       font-size: 20px;
///     }
///   }
@mixin respond-to($breakpoint) {
  @if map.has-key($breakpoints, $breakpoint) {
    $value: map.get($breakpoints, $breakpoint);
    @if $value == 0 {
      @content; // No media query for base/xs breakpoint
    } @else {
      @media (min-width: $value) {
        @content;
      }
    }
  } @else {
    @error "Breakpoint '#{$breakpoint}' not found in $breakpoints. Available breakpoints: #{map.keys($breakpoints)}";
  }
}

/// Get a breakpoint value from the $breakpoints map (derived from $scale)
/// @param {String} $breakpoint - The breakpoint name
/// @return {Number} The breakpoint value in pixels
/// @example scss - Usage
///   $tablet-width: breakpoint('m'); // Returns 600px
@function breakpoint($breakpoint) {
  @if map.has-key($breakpoints, $breakpoint) {
    @return map.get($breakpoints, $breakpoint);
  } @else {
    @error "Breakpoint '#{$breakpoint}' not found in $breakpoints. Available breakpoints: #{map.keys($breakpoints)}";
  }
}

//==================================================================================
// PRIVATE VARIABLES (do not override directly)
//==================================================================================
// These are derived from the scale and preset, and used internally.
$_base-font-size: map.get(map.get($scale, 'xs'), 'font-size'); // px
$_base-scale: 2; // Number of vertical grid units per line
$_base-unit: math.div(map.get(map.get($scale, 'xs'), 'line-height'), $_base-scale); // px

//==================================================================================
// FONT METRICS PRESETS (expand for more fonts)
//==================================================================================
$_presets: (
  'Georgia': (
    'EmSize': 2048,
    'CapHeight': 1419, // 0.6928
    'XHeight': 986,
    'Ascent': 1878, // 0.917
    'Descent': 449, // 0.219
    'LineGap': 198
  )
);
// Metrics calculations for vertical alignment (relative to font-size)
$_line-height-normal: math.div(
  map.get(map.get($_presets, $preset), 'Ascent') +
  map.get(map.get($_presets, $preset), 'Descent') +
  map.get(map.get($_presets, $preset), 'LineGap'),
  map.get(map.get($_presets, $preset), 'EmSize')
);
$_content-area: math.div(
  $_line-height-normal * map.get(map.get($_presets, $preset), 'CapHeight'),
  map.get(map.get($_presets, $preset), 'EmSize')
);
$_distance-top: math.div(
  map.get(map.get($_presets, $preset), 'Ascent') - map.get(map.get($_presets, $preset), 'CapHeight'),
  map.get(map.get($_presets, $preset), 'EmSize')
);
$_distance-bottom: math.div(
  map.get(map.get($_presets, $preset), 'Descent'),
  map.get(map.get($_presets, $preset), 'EmSize')
);
$_vertical-align: $_distance-bottom - $_distance-top;

//==================================================================================
// UTILITY FUNCTIONS
//==================================================================================
// Convert px to em units (relative to font-size)
@function em($px, $font-size: $_base-font-size) {
  @return math.div($px, $font-size) + em;
}
// Convert px to rem units (relative to root font-size)
@function rem($px, $font-size: $_base-font-size) {
  @return math.div($px, $font-size) + rem;
}
// Calculate horizontal grid units (for padding/margin)
@function horizontal-grid-units($q: 1, $px: null) {
  @if ($px) {
    @return math.ceil($q * $_base-unit * $width-optical-adjustment);
  } @else {
    @return calc(#{$q} * var(--base-unit) * #{$width-optical-adjustment});
  }
}
// Short alias for horizontal grid units
@function h($q: 1, $px: null) {
  @return horizontal-grid-units($q, $px);
}
// Horizontal grid units for right side (optically adjusted)
@function h-right($q: 1) {
  @return h($q * $right-side-adjustment);
}
// Calculate vertical grid units (for padding/margin)
@function vertical-grid-units($q: 1) {
  @return calc(#{$q} * var(--base-unit));
}
// Short alias for vertical grid units
@function v($q: 1) {
  @return vertical-grid-units($q);
}
// Get a property from a font preset
@function getFromPreset($preset: 'Georgia', $prop: 'EmSize') {
  @return map.get(map.get($_presets, $preset), $prop);
}
/// Get a specific property value from a breakpoint in the scale
/// @param {String} $breakpoint - Breakpoint name ('xs', 's', 'm', 'l', 'xl', 'xxl', 'ul')
/// @param {String} $property - Property name ('font-size', 'line-height', 'min-width', 'pad')
/// @return {*} Property value from scale configuration
/// @throws Error if breakpoint or property doesn't exist
/// @example scss - Get font size
///   $xs-size: bg.getFromScale('xs', 'font-size');  // 15px
///   $l-line: bg.getFromScale('l', 'line-height');   // 30px
@function getFromScale($breakpoint, $property) {
  @if not map.has-key($scale, $breakpoint) {
    @error 'baselinegrid.scss: Breakpoint "#{$breakpoint}" not found in scale. Available breakpoints: #{map.keys($scale)}';
  }
  
  $bp-config: map.get($scale, $breakpoint);
  
  @if not map.has-key($bp-config, $property) {
    @error 'baselinegrid.scss: Property "#{$property}" not found in breakpoint "#{$breakpoint}". Available properties: #{map.keys($bp-config)}';
  }
  
  @return map.get($bp-config, $property);
}

//==================================================================================
// CONFIGURATION QUERY FUNCTION
//==================================================================================

/// Get current baselinegrid configuration
/// Useful for debugging and verifying configuration
/// @return {Map} Configuration map with scale, settings, and computed values
/// @example scss - Get configuration
///   $config: bg.get-config();
///   @debug $config;
@function get-config() {
  @return (
    'scale': $scale,
    'breakpoints': map.keys($scale),
    'width-optical-adjustment': $width-optical-adjustment,
    'debug': $debug,
    'preset': $preset,
    'version': '2.2.0'
  );
}

/// Get all breakpoint names from scale
/// @return {List} List of breakpoint names
/// @example scss - Get breakpoints
///   $breakpoints: bg.get-breakpoints();
///   // Returns: ('xs', 's', 'm', 'l', 'xl', 'xxl', 'ul')
@function get-breakpoints() {
  @return map.keys($scale);
}

/// Check if a breakpoint exists in scale
/// @param {String} $breakpoint - Breakpoint name to check
/// @return {Boolean} True if breakpoint exists
/// @example scss - Check breakpoint
///   @if bg.has-breakpoint('xl') {
///     // Safe to use 'xl'
///   }
@function has-breakpoint($breakpoint) {
  @return map.has-key($scale, $breakpoint);
}

//==================================================================================
// MIXINS (PUBLIC API)
//==================================================================================

// Debug mixin: visually highlight an element for debugging grid alignment
@mixin debug($v: 0) {
  @debug "#{$v}";
  background-color: rgba(255,0,0,0.6);
  &:before {
    content: unquote("'" + $v + "'");
    color: white;
    padding: 0 h(0.5);
    position: absolute;
    background-color: red;
    font-weight: normal;
    margin-left: h(-1);
  }
}

// Padding/margin utility mixins (accept grid units as argument)
@mixin pad($q: 1) { padding: v($q) h-right($q) v($q) h($q); }
@mixin marg($q: 1) { margin: v($q) h-right($q) v($q) h($q); }
@mixin padh($q: 1) { padding-right: h-right($q); padding-left: h($q); }
@mixin margh($q: 1) { margin-right: h-right($q); margin-left: h($q); }
@mixin padv($q: 1) { padding-top: v($q); padding-bottom: v($q); }
@mixin margv($q: 1) { margin-top: v($q); margin-bottom: v($q); }

// Responsive padding: applies scale-based padding at breakpoints
@mixin pad-scale() {
  @include pad(getFromScale('xs','pad'));
  @each $size, $props in $scale {
    @if (map.get($props, 'min-width') > 0) {
      @include respond-to($size) {
        @include pad(getFromScale($size, 'pad'));
      }
    }
  }
}
// Responsive horizontal padding
@mixin padh-scale() {
  @include padh(getFromScale('xs','pad'));
  @each $size, $props in $scale {
    @if (map.get($props, 'min-width') > 0) {
      @include respond-to($size) {
        @include padh(getFromScale($size, 'pad'));
      }
    }
  }
}

/// Initialize baseline grid system (call once in global styles)
/// Sets vertical-align: baseline on pseudo-elements for consistent alignment
/// @example scss - Initialize
///   @use 'baselinegrid.scss/baselinegrid' as bg;
///   @include bg.begin();
@mixin begin() {
  body *:before,
  body *:after {
    display: inline-block;
    vertical-align: baseline;
  }
}

// Override the scale map (for advanced customization)
@mixin set-scale($my-scale: $scale) {
  $scale: $my-scale;
}

/// Apply baseline grid to root element (html or body)
/// Sets CSS custom properties and base font/line-height
/// @example scss - Apply to root
///   html {
///     @include bg.root();
///   }
@mixin root() {
  --base-font-size: #{getFromScale('xs','font-size')};
  --base-line-height: #{getFromScale('xs','line-height')};
  @each $size, $props in $scale {
    @if (map.get($props, 'min-width') > 0) {
      @include respond-to($size) {
        $font-size: getFromScale($size, 'font-size');
        $line-height: getFromScale($size, 'line-height');
        --base-font-size: #{$font-size};
        --base-line-height: #{$line-height};
      }
    }
  }
  & {
    --base-unit: calc(var(--base-line-height) / #{$_base-scale});
    font-size: var(--base-font-size);
    line-height: var(--base-line-height);
    @if ($debug == 1) {
      @include show-grid();
    }
  }
}

// Show the baseline grid as a background image (for debugging)
@mixin show-grid() {
  background-image: linear-gradient(
    to bottom,
    rgba(0,0,0,0.2) 0%,
    transparent 10%
  );
  background-size: 100% var(--base-unit);
  background-position: left top;
}

/// Set baseline-aligned font-size and line-height on element
/// @param {Number} $size [null] - Optional font size (uses scale default if null)
/// @param {Number} $line-height [null] - Optional line height (uses scale default if null)
/// @example scss - Apply baseline
///   p, li {
///     @include bg.set();
///   }
@mixin set(
  $font-size: $_base-font-size,
  $line-height: $_base-unit
) {
  // Calculate number of base units that fit the font-size
  $lines: math.ceil(math.div($font-size, $_base-unit));
  $line-height: $_base-unit * $lines;

  @if ($font-size != $_base-font-size) {
    font-size: #{$font-size};
    --line-height: calc(var(--base-unit) * #{$lines});
    line-height: var(--line-height);
    &:before, &:after {
      height: var(--line-height);
      content: '';
    }
    &:after {
      vertical-align: calc(var(--line-height) * -1);
    }
    // Responsive adjustments for breakpoints
    @each $size, $props in $scale {
      @if (map.get($props, 'min-width') > 0) {
        @include respond-to($size) {
          $base-font-size: getFromScale($size, 'font-size');
          font-size: $font-size;
          $base-unit: math.div(getFromScale($size, 'line-height'), $_base-scale);
          --base-unit: #{$base-unit};
          $lines: math.ceil(math.div($font-size, $base-unit));
          --line-height: calc(var(--base-unit) * #{$lines});
          line-height: var(--line-height);
        }
      }
    }
  } @else {
    &:before, &:after {
      height: var(--base-line-height);
      content: '';
    }
    &:after {
      vertical-align: calc(var(--base-line-height) * -1);
    }
  }
  // Uncomment to apply vertical alignment correction based on font metrics:
  // $translate: $_vertical-align * $font-size;
  // transform: translateY(rem($translate));
}

/// Apply responsive values to a CSS property across breakpoints
/// @param {String} $property - CSS property name (e.g., 'font-size', 'padding')
/// @param {Map} $value-map - Map of breakpoint â†’ value pairs
/// @example scss - Responsive padding
///   @include bg.scale('padding', (
///     'xs': bg.v(2),
///     'm': bg.v(3),
///     'xl': bg.v(4)
///   ));
@mixin scale($prop: 'font-size', $scale: null) {
  @if ($scale) {
    @if ($prop == 'font-size') {
      @each $size, $font-size in $scale {
        @if (getFromScale($size, 'min-width') > 0) {
          @include respond-to($size) {
            font-size: $font-size;
            $base-unit: math.div(getFromScale($size, 'line-height'), $_base-scale);
            --base-unit: #{$base-unit};
            $lines: math.ceil(math.div($font-size, $base-unit));
            --line-height: calc(var(--base-unit) * #{$lines});
            line-height: var(--line-height);
          }
        } @else {
          $lines: math.ceil(math.div($font-size, $_base-unit));
          $line-height: $_base-unit * $lines;
          font-size: #{$font-size};
          --line-height: calc(var(--base-unit) * #{$lines});
          line-height: var(--line-height);
        }
      }
      &:before, &:after {
        height: var(--line-height);
        content: '';
      }
      &:after {
        vertical-align: calc(var(--line-height) * -1);
      }
    } @else {
      @each $size, $value in $scale {
        @if (getFromScale($size, 'min-width') > 0) {
          @include respond-to($size) {
            #{$prop}: $value;
          }
        } @else {
          #{$prop}: $value;
        }
      }
    }
  }
}

//==================================================================================
// LEGACY/EXPERIMENTAL MIXINS (not recommended for new code)
//==================================================================================
// These are kept for reference and backward compatibility.
// Use the main mixins above for new projects.

@mixin align-old(
  $font-size: $_base-font-size,
  $offset-top: 0,
  $offset-bottom: 0,
  $media: null
) {
  $base-font-size: $_base-font-size;
  @if ($media) {
    $base-font-size: map.get($medias-base-font-sizes, $media);
  }
  $lines: math.ceil(math.div($font-size, $_base-unit));
  $line-height: $_base-unit * $lines;
  $baseline-distance: math.div(($_base-unit - $base-cap-height), $_base-scale) * $base-font-size;
  $offset-top: $offset-top * $_base-unit;
  $offset-bottom: $offset-bottom * $_base-unit;
  $padding-top: $baseline-distance + $offset-top;
  $margin-bottom: $line-height - $baseline-distance - $_base-unit + $offset-bottom;
  @include box(
    $font-size,
    $line-height,
    $padding-top,
    $margin-bottom,
    $media,
  );
}

@mixin box(
  $font-size: $_base-font-size,
  $line-height: $_base-unit,
  $padding-top: 0,
  $margin-bottom: 0,
  $media: null,
) {
  @if ($media and map.get($medias, $media)) {
    @media (min-width: h(map.get($medias, $media))) {
      font-size: rem($font-size, map.get($medias-base-font-sizes, $media));
      // line-height: rem($line-height);
      padding-top: rem($padding-top, map.get($medias-base-font-sizes, $media));
      margin-bottom: rem($margin-bottom, map.get($medias-base-font-sizes, $media));
    }
  } @else {
    font-size: rem($font-size);
    line-height: rem($line-height);
    padding-top: rem($padding-top);
    padding-bottom: rem($margin-bottom);
    vertical-align: rem($_vertical-align * $font-size);
    // @if ($debug == 1) { @include debug($font-size); }
  }
}

//==================================================================================
// END OF baselinegrid.scss
//==================================================================================
